name: Sysmon Detection Testing

on:
  push:
    paths:
      - 'configs/*.xml'
      - 'tests/**'
      - '.github/workflows/sysmon-test.yml'
  pull_request:
    paths:
      - 'configs/*.xml'
  workflow_dispatch:
    inputs:
      config_type:
        description: 'Config to test (ws, srv, dc, sql, exch, iis, all)'
        required: true
        default: 'all'

jobs:
  validate-xml:
    name: Validate XML Syntax
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install xmllint
        run: sudo apt-get update && sudo apt-get install -y libxml2-utils

      - name: Validate Sysmon XML files
        run: |
          echo "Validating Sysmon configuration XML syntax..."
          if ls configs/sysmon-*.xml 1> /dev/null 2>&1; then
            for file in configs/sysmon-*.xml; do
              echo "Checking $file..."
              xmllint --noout "$file" && echo "  ✓ Valid XML" || exit 1
            done
            echo "All XML files are valid!"
          else
            echo "No XML files found in configs/ directory"
            ls -la configs/ || echo "configs directory not found"
            exit 1
          fi

  test-sysmon-configs:
    name: Test ${{ matrix.config }} Config
    needs: validate-xml
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        config: [ws, srv, dc, sql, exch, iis]

    steps:
      - uses: actions/checkout@v4

      - name: Download Sysmon
        shell: powershell
        run: |
          Write-Host "Downloading Sysmon from Sysinternals..."
          $ProgressPreference = 'SilentlyContinue'
          Invoke-WebRequest -Uri "https://download.sysinternals.com/files/Sysmon.zip" -OutFile "Sysmon.zip"
          Expand-Archive -Path "Sysmon.zip" -DestinationPath ".\Sysmon" -Force
          Write-Host "Sysmon downloaded successfully"

      - name: Install Sysmon with ${{ matrix.config }} config
        shell: powershell
        run: |
          $configFile = "configs\sysmon-${{ matrix.config }}.xml"
          Write-Host "Installing Sysmon with config: $configFile"

          # Install Sysmon - ignore stderr as Sysmon writes info there
          $ErrorActionPreference = 'SilentlyContinue'
          & .\Sysmon\Sysmon64.exe -accepteula -i $configFile *>&1 | Write-Host
          $ErrorActionPreference = 'Continue'

          # Wait for service to start
          Start-Sleep -Seconds 5

          # Verify installation - this is what matters
          $service = Get-Service -Name Sysmon64 -ErrorAction SilentlyContinue
          if ($service -and $service.Status -eq 'Running') {
            Write-Host '[OK] Sysmon installed and running' -ForegroundColor Green
            exit 0
          } else {
            Write-Host '[FAIL] Sysmon installation failed' -ForegroundColor Red
            exit 1
          }

      - name: Run Detection Tests
        id: detection_test
        shell: powershell
        run: |
          Write-Host "Running detection tests for ${{ matrix.config }} configuration..."
          Write-Host "=" * 60

          # Source the test functions
          . .\tests\Test-SysmonDetection.ps1 -ConfigType "${{ matrix.config }}" -CI

        continue-on-error: true

      - name: Collect Sysmon Events
        if: always()
        shell: powershell
        run: |
          Write-Host "Collecting Sysmon events generated during tests..."

          $events = Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -MaxEvents 500 -ErrorAction SilentlyContinue

          if ($events) {
            Write-Host "Total events captured: $($events.Count)"
            Write-Host ""

            # Summary by Event ID
            Write-Host "Events by Type:"
            Write-Host "-" * 40
            $events | Group-Object Id | Sort-Object Name | ForEach-Object {
              $eventName = switch ($_.Name) {
                1  { "ProcessCreate" }
                2  { "FileCreateTime" }
                3  { "NetworkConnect" }
                5  { "ProcessTerminate" }
                6  { "DriverLoad" }
                7  { "ImageLoad" }
                8  { "CreateRemoteThread" }
                9  { "RawAccessRead" }
                10 { "ProcessAccess" }
                11 { "FileCreate" }
                12 { "RegistryAddDelete" }
                13 { "RegistryValueSet" }
                14 { "RegistryRename" }
                15 { "FileCreateStreamHash" }
                17 { "PipeCreated" }
                18 { "PipeConnected" }
                19 { "WmiFilterCreate" }
                20 { "WmiConsumerCreate" }
                21 { "WmiBindingCreate" }
                22 { "DnsQuery" }
                23 { "FileDelete" }
                24 { "ClipboardChange" }
                25 { "ProcessTampering" }
                26 { "FileDeleteDetected" }
                default { "Unknown" }
              }
              Write-Host ("  Event {0,2} ({1,-20}): {2}" -f $_.Name, $eventName, $_.Count)
            }

            # Export to artifact
            $events | Select-Object TimeCreated, Id, Message |
              Export-Csv -Path "sysmon-events-${{ matrix.config }}.csv" -NoTypeInformation

          } else {
            Write-Host "No Sysmon events captured - config may be too restrictive"
          }

      - name: Upload Event Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sysmon-events-${{ matrix.config }}
          path: sysmon-events-${{ matrix.config }}.csv
          if-no-files-found: ignore

      - name: Uninstall Sysmon
        if: always()
        shell: powershell
        run: |
          Write-Host 'Cleaning up Sysmon...'
          $svc = Get-Service -Name Sysmon64 -ErrorAction SilentlyContinue
          if ($svc) {
            $ErrorActionPreference = 'SilentlyContinue'
            & .\Sysmon\Sysmon64.exe -u force *>&1 | Out-Null
            Write-Host 'Sysmon uninstalled'
          } else {
            Write-Host 'Sysmon was not installed, skipping cleanup'
          }
          exit 0

  atomic-red-team:
    name: Atomic Red Team - ${{ matrix.config }}
    needs: validate-xml
    runs-on: windows-latest
    if: github.event_name == 'workflow_dispatch'
    strategy:
      fail-fast: false
      matrix:
        config: [ws, srv, dc, sql, exch, iis]

    steps:
      - uses: actions/checkout@v4

      - name: Download Sysmon
        shell: powershell
        run: |
          $ProgressPreference = 'SilentlyContinue'
          Invoke-WebRequest -Uri "https://download.sysinternals.com/files/Sysmon.zip" -OutFile "Sysmon.zip"
          Expand-Archive -Path "Sysmon.zip" -DestinationPath ".\Sysmon" -Force

      - name: Install Sysmon
        shell: powershell
        run: |
          $ErrorActionPreference = 'SilentlyContinue'
          & .\Sysmon\Sysmon64.exe -accepteula -i "configs\sysmon-${{ matrix.config }}.xml" *>&1 | Write-Host
          Start-Sleep -Seconds 5
          $service = Get-Service -Name Sysmon64 -ErrorAction SilentlyContinue
          if ($service -and $service.Status -eq 'Running') {
            Write-Host '[OK] Sysmon installed'
            exit 0
          } else {
            Write-Host '[FAIL] Sysmon not running'
            exit 1
          }

      - name: Install Atomic Red Team
        shell: powershell
        run: |
          Write-Host "Installing Atomic Red Team..."
          IEX (IWR 'https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/install-atomicredteam.ps1' -UseBasicParsing)
          Install-AtomicRedTeam -getAtomics -Force -ErrorAction SilentlyContinue
          Write-Host "Atomic Red Team installed"

      - name: Run Atomic Tests with Detection Matching
        shell: powershell
        run: |
          Write-Host "Running Atomic Red Team tests with detection matching..."
          Write-Host "Configuration: ${{ matrix.config }}"
          Write-Host ""

          # Import module
          Import-Module "C:\AtomicRedTeam\invoke-atomicredteam\Invoke-AtomicRedTeam.psd1" -Force

          # 40 KEY techniques - balanced coverage across MITRE ATT&CK
          # Reduced from 104 to avoid GitHub Actions timeout
          $allTechniques = @(
            # === EXECUTION (5) ===
            "T1059.001",  # PowerShell
            "T1059.003",  # Windows Command Shell
            "T1047",      # WMI
            "T1106",      # Native API
            "T1204.002",  # Malicious File

            # === PERSISTENCE (5) ===
            "T1547.001",  # Registry Run Keys
            "T1053.005",  # Scheduled Task
            "T1543.003",  # Windows Service
            "T1546.003",  # WMI Event Subscription
            "T1136.001",  # Local Account

            # === PRIVILEGE ESCALATION (2) ===
            "T1548.002",  # Bypass UAC
            "T1134.001",  # Token Impersonation

            # === DEFENSE EVASION (8) ===
            "T1218.005",  # Mshta
            "T1218.010",  # Regsvr32
            "T1218.011",  # Rundll32
            "T1027",      # Obfuscated Files
            "T1140",      # Deobfuscate/Decode
            "T1070.001",  # Clear Windows Event Logs
            "T1070.004",  # File Deletion
            "T1562.001",  # Disable Security Tools

            # === CREDENTIAL ACCESS (5) ===
            "T1003.001",  # LSASS Memory
            "T1003.002",  # SAM
            "T1003.003",  # NTDS
            "T1552.001",  # Credentials in Files
            "T1555.003",  # Credentials from Web Browsers

            # === DISCOVERY (8) ===
            "T1087.001",  # Local Account
            "T1087.002",  # Domain Account
            "T1082",      # System Information
            "T1057",      # Process Discovery
            "T1018",      # Remote System Discovery
            "T1016",      # System Network Config
            "T1069.002",  # Domain Groups
            "T1482",      # Domain Trust Discovery

            # === LATERAL MOVEMENT (2) ===
            "T1021.002",  # SMB/Windows Admin Shares
            "T1570",      # Lateral Tool Transfer

            # === COLLECTION (3) ===
            "T1560.001",  # Archive via Utility
            "T1005",      # Data from Local System
            "T1074.001",  # Local Data Staging

            # === C2 (2) ===
            "T1105",      # Ingress Tool Transfer
            "T1071.001"   # Web Protocols
          )

          # 40 techniques - should complete in ~20-30 minutes
          $techniques = $allTechniques
          $config = "${{ matrix.config }}"

          Write-Host "Testing $($techniques.Count) MITRE ATT&CK techniques for $config configuration"
          Write-Host "=" * 60

          $results = @()

          foreach ($technique in $techniques) {
            Write-Host "`n[*] Testing $technique..." -ForegroundColor Cyan

            # Record start time
            $startTime = Get-Date

            # Get events before test
            $eventsBefore = (Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -MaxEvents 5000 -ErrorAction SilentlyContinue).Count

            try {
              # Execute atomic test
              $ErrorActionPreference = 'SilentlyContinue'
              Invoke-AtomicTest -AtomicTechnique $technique -ErrorAction SilentlyContinue *>&1 | Out-Null

              # Wait for Sysmon to process
              Start-Sleep -Seconds 3

              # Get events after test
              $eventsAfter = Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -MaxEvents 5000 -ErrorAction SilentlyContinue
              $newEvents = $eventsAfter | Where-Object { $_.TimeCreated -ge $startTime }
              $eventCount = $newEvents.Count

              # Get event types generated
              $eventTypes = ($newEvents | Group-Object Id | ForEach-Object { $_.Name }) -join ","

              $detected = $eventCount -gt 0
              $status = if ($detected) { "DETECTED" } else { "NOT_DETECTED" }

              Write-Host "    Events generated: $eventCount [$eventTypes]" -ForegroundColor $(if($detected){'Green'}else{'Yellow'})

              $results += [PSCustomObject]@{
                Technique = $technique
                Config = $config
                Status = $status
                EventCount = $eventCount
                EventTypes = $eventTypes
                Timestamp = $startTime.ToString("yyyy-MM-dd HH:mm:ss")
              }

              # Cleanup after each test
              Invoke-AtomicTest -AtomicTechnique $technique -Cleanup -ErrorAction SilentlyContinue *>&1 | Out-Null
            }
            catch {
              Write-Host "    Error: $($_.Exception.Message)" -ForegroundColor Red
              $results += [PSCustomObject]@{
                Technique = $technique
                Config = $config
                Status = "ERROR"
                EventCount = 0
                EventTypes = ""
                Timestamp = $startTime.ToString("yyyy-MM-dd HH:mm:ss")
              }
            }
          }

          # Summary
          Write-Host "`n" + "=" * 60
          Write-Host "DETECTION COVERAGE SUMMARY - $config"
          Write-Host "=" * 60

          $detected = ($results | Where-Object { $_.Status -eq "DETECTED" }).Count
          $notDetected = ($results | Where-Object { $_.Status -eq "NOT_DETECTED" }).Count
          $errors = ($results | Where-Object { $_.Status -eq "ERROR" }).Count
          $total = $results.Count
          $rate = if ($total -gt 0) { [math]::Round(($detected / $total) * 100, 1) } else { 0 }

          Write-Host "Techniques Tested: $total"
          Write-Host "Detected: $detected" -ForegroundColor Green
          Write-Host "Not Detected: $notDetected" -ForegroundColor Yellow
          Write-Host "Errors: $errors" -ForegroundColor Red
          Write-Host "Detection Rate: $rate%" -ForegroundColor Cyan

          # Export detailed results
          $results | Export-Csv -Path "detection-coverage-${{ matrix.config }}.csv" -NoTypeInformation

          # Create markdown summary
          $mdContent = @"
          # Detection Coverage Report - $config

          **Date:** $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
          **Configuration:** $config
          **Detection Rate:** $rate%

          ## Summary
          | Metric | Count |
          |--------|-------|
          | Techniques Tested | $total |
          | Detected | $detected |
          | Not Detected | $notDetected |
          | Errors | $errors |

          ## Detailed Results
          | Technique | Status | Events | Event Types |
          |-----------|--------|--------|-------------|
          "@

          foreach ($r in $results) {
            $mdContent += "`n| $($r.Technique) | $($r.Status) | $($r.EventCount) | $($r.EventTypes) |"
          }

          $mdContent | Out-File -FilePath "detection-report-${{ matrix.config }}.md" -Encoding UTF8

      - name: Collect Detection Results
        if: always()
        shell: powershell
        run: |
          $events = Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -MaxEvents 1000 -ErrorAction SilentlyContinue

          Write-Host "Events captured: $($events.Count)"
          Write-Host ""

          $events | Group-Object Id | Sort-Object Count -Descending | ForEach-Object {
            Write-Host "  Event $($_.Name): $($_.Count)"
          }

          $events | Select-Object TimeCreated, Id, Message |
            Export-Csv -Path "atomic-events-${{ matrix.config }}.csv" -NoTypeInformation

      - name: Upload Detection Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: detection-results-${{ matrix.config }}
          path: |
            detection-coverage-${{ matrix.config }}.csv
            detection-report-${{ matrix.config }}.md
            atomic-events-${{ matrix.config }}.csv
          if-no-files-found: ignore

      - name: Cleanup
        if: always()
        shell: powershell
        run: |
          $svc = Get-Service -Name Sysmon64 -ErrorAction SilentlyContinue
          if ($svc) {
            $ErrorActionPreference = 'SilentlyContinue'
            & .\Sysmon\Sysmon64.exe -u force *>&1 | Out-Null
          }
          exit 0

  # ==========================================================================
  # WINDOWS EVENT LOGGING TESTS
  # Verifies that Windows Audit Policies generate expected security events
  # ==========================================================================
  windows-event-tests:
    name: Windows Events - ${{ matrix.config }}
    needs: validate-xml
    runs-on: windows-latest
    if: github.event_name == 'workflow_dispatch'
    strategy:
      fail-fast: false
      matrix:
        config: [ws, srv, dc]  # Test on workstation, server, and DC configs

    steps:
      - uses: actions/checkout@v4

      - name: Apply Windows Audit Policy
        shell: powershell
        continue-on-error: true  # Some policies may fail on specific Windows versions
        run: |
          Write-Host "Applying Windows Audit Policy for security event testing..."
          Write-Host "=" * 60

          # Run the audit policy script - ignore exit code as some policies may not apply
          $ErrorActionPreference = 'Continue'
          & .\deploy\windows-audit-policy.ps1 -Verbose

          # Force success - we care about events, not policy application
          Write-Host "Audit policy configuration attempted"
          exit 0

      - name: Generate Test Events
        shell: powershell
        run: |
          Write-Host "Generating security events for validation..."
          Write-Host "=" * 60

          $testUser = "TestAuditUser"
          $testGroup = "TestAuditGroup"
          $results = @()

          # ============================================================
          # TEST 1: User Account Management (4720, 4722, 4724)
          # ============================================================
          Write-Host "`n[TEST] User Account Management Events (4720, 4722, 4724)..."
          try {
            # 4720 - User Account Created
            net user $testUser "P@ssw0rd123!" /add 2>&1 | Out-Null
            Write-Host "  [+] Created user: $testUser (should trigger 4720)"

            # 4724 - Password Reset
            net user $testUser "NewP@ssw0rd!" 2>&1 | Out-Null
            Write-Host "  [+] Reset password (should trigger 4724)"

            # 4725 - User Account Disabled + 4722 - User Account Enabled
            net user $testUser /active:no 2>&1 | Out-Null
            net user $testUser /active:yes 2>&1 | Out-Null
            Write-Host "  [+] Disabled/Enabled user (should trigger 4725, 4722)"

            $results += [PSCustomObject]@{Test="UserManagement"; Status="OK"; Events="4720,4722,4724,4725"}
          }
          catch {
            Write-Host "  [!] Error: $($_.Exception.Message)" -ForegroundColor Red
            $results += [PSCustomObject]@{Test="UserManagement"; Status="FAIL"; Events=""}
          }

          # ============================================================
          # TEST 2: Security Group Management (4728, 4732)
          # ============================================================
          Write-Host "`n[TEST] Security Group Management Events (4728, 4732)..."
          try {
            # Create local group
            net localgroup $testGroup /add 2>&1 | Out-Null
            Write-Host "  [+] Created group: $testGroup"

            # 4732 - Member Added to Local Group
            net localgroup $testGroup $testUser /add 2>&1 | Out-Null
            Write-Host "  [+] Added user to group (should trigger 4732)"

            # 4733 - Member Removed from Local Group
            net localgroup $testGroup $testUser /delete 2>&1 | Out-Null
            Write-Host "  [+] Removed user from group (should trigger 4733)"

            $results += [PSCustomObject]@{Test="GroupManagement"; Status="OK"; Events="4732,4733"}
          }
          catch {
            Write-Host "  [!] Error: $($_.Exception.Message)" -ForegroundColor Red
            $results += [PSCustomObject]@{Test="GroupManagement"; Status="FAIL"; Events=""}
          }

          # ============================================================
          # TEST 3: Failed Logon (4625)
          # ============================================================
          Write-Host "`n[TEST] Failed Logon Event (4625)..."
          try {
            # Trigger failed logon
            $secpasswd = ConvertTo-SecureString "WrongPassword" -AsPlainText -Force
            $cred = New-Object System.Management.Automation.PSCredential ("FakeUser", $secpasswd)
            Start-Process cmd -Credential $cred -ErrorAction SilentlyContinue 2>&1 | Out-Null
          }
          catch {
            Write-Host "  [+] Failed logon triggered (should generate 4625)"
            $results += [PSCustomObject]@{Test="FailedLogon"; Status="OK"; Events="4625"}
          }

          # ============================================================
          # TEST 4: Scheduled Task (4698, 4699)
          # ============================================================
          Write-Host "`n[TEST] Scheduled Task Events (4698, 4699)..."
          try {
            $taskName = "TestAuditTask"

            # 4698 - Scheduled Task Created
            schtasks /create /tn $taskName /tr "cmd /c echo test" /sc once /st 00:00 /f 2>&1 | Out-Null
            Write-Host "  [+] Created scheduled task (should trigger 4698)"

            # 4699 - Scheduled Task Deleted
            schtasks /delete /tn $taskName /f 2>&1 | Out-Null
            Write-Host "  [+] Deleted scheduled task (should trigger 4699)"

            $results += [PSCustomObject]@{Test="ScheduledTask"; Status="OK"; Events="4698,4699"}
          }
          catch {
            Write-Host "  [!] Error: $($_.Exception.Message)" -ForegroundColor Red
            $results += [PSCustomObject]@{Test="ScheduledTask"; Status="FAIL"; Events=""}
          }

          # ============================================================
          # TEST 5: Service Installation (4697)
          # ============================================================
          Write-Host "`n[TEST] Service Installation Event (4697)..."
          try {
            $serviceName = "TestAuditService"

            # 4697 - Service Installed
            sc.exe create $serviceName binPath= "cmd /c echo test" type= own start= demand 2>&1 | Out-Null
            Write-Host "  [+] Created service (should trigger 4697)"

            # Cleanup
            sc.exe delete $serviceName 2>&1 | Out-Null
            Write-Host "  [+] Deleted service"

            $results += [PSCustomObject]@{Test="ServiceInstall"; Status="OK"; Events="4697"}
          }
          catch {
            Write-Host "  [!] Error: $($_.Exception.Message)" -ForegroundColor Red
            $results += [PSCustomObject]@{Test="ServiceInstall"; Status="FAIL"; Events=""}
          }

          # ============================================================
          # TEST 6: Explicit Credentials (4648)
          # ============================================================
          Write-Host "`n[TEST] Explicit Credentials Event (4648)..."
          try {
            # Use runas to trigger 4648
            $proc = Start-Process -FilePath "cmd.exe" -ArgumentList "/c whoami" -Verb RunAs -PassThru -ErrorAction SilentlyContinue
            if ($proc) {
              Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue
            }
            Write-Host "  [+] Explicit credentials used (should trigger 4648)"
            $results += [PSCustomObject]@{Test="ExplicitCreds"; Status="OK"; Events="4648"}
          }
          catch {
            Write-Host "  [!] Note: 4648 may require interactive session"
            $results += [PSCustomObject]@{Test="ExplicitCreds"; Status="SKIP"; Events="4648"}
          }

          # Wait for events to be written
          Start-Sleep -Seconds 5

          # Summary
          Write-Host "`n" + "=" * 60
          Write-Host "TEST GENERATION SUMMARY"
          Write-Host "=" * 60
          $results | Format-Table -AutoSize

          # Export results
          $results | Export-Csv -Path "event-generation-results.csv" -NoTypeInformation

      - name: Enable PowerShell Logging
        shell: powershell
        continue-on-error: true
        run: |
          Write-Host "Enabling PowerShell logging..."
          $ErrorActionPreference = 'Continue'
          & .\deploy\enable-powershell-logging.ps1 -Verbose
          Write-Host "PowerShell logging configured"
          exit 0

      - name: Generate PowerShell Events
        shell: powershell
        run: |
          Write-Host "Generating PowerShell events (4103, 4104)..."
          Write-Host "=" * 60

          # Wait for logging to take effect
          Start-Sleep -Seconds 2

          # ============================================================
          # TEST: Script Block Logging (4104)
          # ============================================================
          Write-Host "`n[TEST] Script Block Logging (Event 4104)..."

          # Execute various PowerShell commands to trigger 4104
          $testScript = {
            $env:COMPUTERNAME
            Get-Process | Select-Object -First 1
            Get-Service | Select-Object -First 1
            [System.Net.Dns]::GetHostName()
          }
          & $testScript
          Write-Host "  [+] Executed script block (should trigger 4104)"

          # Encoded command (common attack pattern - should be logged)
          $encoded = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes("Get-Date"))
          powershell -EncodedCommand $encoded 2>&1 | Out-Null
          Write-Host "  [+] Executed encoded command (should trigger 4104)"

          # ============================================================
          # TEST: Module Logging (4103)
          # ============================================================
          Write-Host "`n[TEST] Module Logging (Event 4103)..."

          # Import and use modules to trigger 4103
          Import-Module Microsoft.PowerShell.Management -Force
          Get-ChildItem C:\ -ErrorAction SilentlyContinue | Select-Object -First 1 | Out-Null
          Write-Host "  [+] Used Management module (should trigger 4103)"

          Import-Module Microsoft.PowerShell.Utility -Force
          Get-Random -Maximum 100 | Out-Null
          Write-Host "  [+] Used Utility module (should trigger 4103)"

          # Wait for events to be written
          Start-Sleep -Seconds 3

          Write-Host "`nPowerShell event generation complete"

      - name: Verify Windows Events Generated
        shell: powershell
        run: |
          Write-Host "Verifying Windows Security Events were generated..."
          Write-Host "=" * 60

          # Expected Security events and their descriptions
          $expectedSecurityEvents = @{
            4625 = "Failed Logon (Brute Force Detection)"
            4720 = "User Account Created"
            4722 = "User Account Enabled"
            4724 = "Password Reset Attempt"
            4725 = "User Account Disabled"
            4732 = "Member Added to Local Group"
            4733 = "Member Removed from Local Group"
            4697 = "Service Installed"
            4698 = "Scheduled Task Created"
            4699 = "Scheduled Task Deleted"
            4672 = "Special Privileges Assigned"
            4648 = "Explicit Credentials Used"
          }

          # Expected PowerShell events
          $expectedPowerShellEvents = @{
            4103 = "PowerShell Module Logging"
            4104 = "PowerShell Script Block Logging"
          }

          $results = @()
          $rawEventData = @()
          $totalDetected = 0
          $totalMissing = 0

          # Get events from last 10 minutes
          $startTime = (Get-Date).AddMinutes(-10)

          Write-Host "`nChecking for expected events since $startTime..."
          Write-Host "-" * 60

          # Check Security Events
          Write-Host "`n[Security Log Events]" -ForegroundColor Cyan
          foreach ($eventId in $expectedSecurityEvents.Keys | Sort-Object) {
            $description = $expectedSecurityEvents[$eventId]

            try {
              $events = Get-WinEvent -FilterHashtable @{
                LogName = 'Security'
                Id = $eventId
                StartTime = $startTime
              } -MaxEvents 10 -ErrorAction SilentlyContinue

              $count = if ($events) { $events.Count } else { 0 }

              if ($count -gt 0) {
                Write-Host "[OK] Event $eventId : $description ($count events)" -ForegroundColor Green
                $status = "DETECTED"
                $totalDetected++

                # Output RAW EVENT DATA for each event type
                Write-Host "`n    --- RAW EVENT DATA (Event $eventId) ---" -ForegroundColor Magenta
                foreach ($evt in $events | Select-Object -First 3) {
                  Write-Host "    TimeCreated: $($evt.TimeCreated)"

                  # Parse XML for detailed fields
                  $xml = [xml]$evt.ToXml()
                  $eventData = $xml.Event.EventData.Data

                  # Extract key fields based on event type
                  switch ($eventId) {
                    4625 {  # Failed Logon
                      $targetUser = ($eventData | Where-Object { $_.Name -eq 'TargetUserName' }).'#text'
                      $targetDomain = ($eventData | Where-Object { $_.Name -eq 'TargetDomainName' }).'#text'
                      $logonType = ($eventData | Where-Object { $_.Name -eq 'LogonType' }).'#text'
                      $failReason = ($eventData | Where-Object { $_.Name -eq 'FailureReason' }).'#text'
                      $status = ($eventData | Where-Object { $_.Name -eq 'Status' }).'#text'
                      $ipAddress = ($eventData | Where-Object { $_.Name -eq 'IpAddress' }).'#text'
                      Write-Host "    TargetUserName: $targetDomain\$targetUser"
                      Write-Host "    LogonType: $logonType"
                      Write-Host "    Status: $status"
                      Write-Host "    IpAddress: $ipAddress"
                    }
                    4720 {  # User Created
                      $targetUser = ($eventData | Where-Object { $_.Name -eq 'TargetUserName' }).'#text'
                      $targetDomain = ($eventData | Where-Object { $_.Name -eq 'TargetDomainName' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    TargetUserName: $targetDomain\$targetUser"
                      Write-Host "    CreatedBy: $subjectUser"
                    }
                    4722 {  # User Enabled
                      $targetUser = ($eventData | Where-Object { $_.Name -eq 'TargetUserName' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    TargetUserName: $targetUser"
                      Write-Host "    EnabledBy: $subjectUser"
                    }
                    4724 {  # Password Reset
                      $targetUser = ($eventData | Where-Object { $_.Name -eq 'TargetUserName' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    TargetUserName: $targetUser"
                      Write-Host "    ResetBy: $subjectUser"
                    }
                    4725 {  # User Disabled
                      $targetUser = ($eventData | Where-Object { $_.Name -eq 'TargetUserName' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    TargetUserName: $targetUser"
                      Write-Host "    DisabledBy: $subjectUser"
                    }
                    4732 {  # Member Added to Group
                      $memberName = ($eventData | Where-Object { $_.Name -eq 'MemberName' }).'#text'
                      $memberSid = ($eventData | Where-Object { $_.Name -eq 'MemberSid' }).'#text'
                      $targetGroup = ($eventData | Where-Object { $_.Name -eq 'TargetUserName' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    MemberAdded: $memberName ($memberSid)"
                      Write-Host "    TargetGroup: $targetGroup"
                      Write-Host "    AddedBy: $subjectUser"
                    }
                    4733 {  # Member Removed from Group
                      $memberName = ($eventData | Where-Object { $_.Name -eq 'MemberName' }).'#text'
                      $targetGroup = ($eventData | Where-Object { $_.Name -eq 'TargetUserName' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    MemberRemoved: $memberName"
                      Write-Host "    TargetGroup: $targetGroup"
                      Write-Host "    RemovedBy: $subjectUser"
                    }
                    4697 {  # Service Installed
                      $serviceName = ($eventData | Where-Object { $_.Name -eq 'ServiceName' }).'#text'
                      $serviceFile = ($eventData | Where-Object { $_.Name -eq 'ServiceFileName' }).'#text'
                      $serviceType = ($eventData | Where-Object { $_.Name -eq 'ServiceType' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    ServiceName: $serviceName"
                      Write-Host "    ServiceFileName: $serviceFile"
                      Write-Host "    ServiceType: $serviceType"
                      Write-Host "    InstalledBy: $subjectUser"
                    }
                    4698 {  # Scheduled Task Created
                      $taskName = ($eventData | Where-Object { $_.Name -eq 'TaskName' }).'#text'
                      $taskContent = ($eventData | Where-Object { $_.Name -eq 'TaskContent' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    TaskName: $taskName"
                      Write-Host "    CreatedBy: $subjectUser"
                      if ($taskContent) { Write-Host "    TaskContent: $($taskContent.Substring(0, [Math]::Min(200, $taskContent.Length)))..." }
                    }
                    4699 {  # Scheduled Task Deleted
                      $taskName = ($eventData | Where-Object { $_.Name -eq 'TaskName' }).'#text'
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      Write-Host "    TaskName: $taskName"
                      Write-Host "    DeletedBy: $subjectUser"
                    }
                    4672 {  # Special Privileges
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      $privileges = ($eventData | Where-Object { $_.Name -eq 'PrivilegeList' }).'#text'
                      Write-Host "    SubjectUserName: $subjectUser"
                      Write-Host "    Privileges: $($privileges -replace "`n", ', ')"
                    }
                    4648 {  # Explicit Credentials
                      $subjectUser = ($eventData | Where-Object { $_.Name -eq 'SubjectUserName' }).'#text'
                      $targetUser = ($eventData | Where-Object { $_.Name -eq 'TargetUserName' }).'#text'
                      $targetServer = ($eventData | Where-Object { $_.Name -eq 'TargetServerName' }).'#text'
                      $processName = ($eventData | Where-Object { $_.Name -eq 'ProcessName' }).'#text'
                      Write-Host "    SubjectUserName: $subjectUser"
                      Write-Host "    TargetUserName: $targetUser"
                      Write-Host "    TargetServerName: $targetServer"
                      Write-Host "    ProcessName: $processName"
                    }
                  }
                  Write-Host "    ---"

                  # Store raw event data for export
                  $rawEventData += [PSCustomObject]@{
                    EventID = $eventId
                    TimeCreated = $evt.TimeCreated
                    Message = $evt.Message.Substring(0, [Math]::Min(500, $evt.Message.Length))
                  }
                }
                Write-Host ""
              }
              else {
                Write-Host "[--] Event $eventId : $description (not generated)" -ForegroundColor Yellow
                $status = "NOT_DETECTED"
                $totalMissing++
              }

              $results += [PSCustomObject]@{
                EventID = $eventId
                LogName = "Security"
                Description = $description
                Status = $status
                Count = $count
              }
            }
            catch {
              Write-Host "[??] Event $eventId : $description (error reading)" -ForegroundColor Red
              $results += [PSCustomObject]@{
                EventID = $eventId
                LogName = "Security"
                Description = $description
                Status = "ERROR"
                Count = 0
              }
            }
          }

          # Check PowerShell Events
          Write-Host "`n[PowerShell Log Events]" -ForegroundColor Cyan
          foreach ($eventId in $expectedPowerShellEvents.Keys | Sort-Object) {
            $description = $expectedPowerShellEvents[$eventId]

            try {
              $events = Get-WinEvent -FilterHashtable @{
                LogName = 'Microsoft-Windows-PowerShell/Operational'
                Id = $eventId
                StartTime = $startTime
              } -MaxEvents 10 -ErrorAction SilentlyContinue

              $count = if ($events) { $events.Count } else { 0 }

              if ($count -gt 0) {
                Write-Host "[OK] Event $eventId : $description ($count events)" -ForegroundColor Green
                $status = "DETECTED"
                $totalDetected++

                # Output RAW EVENT DATA for PowerShell events
                Write-Host "`n    --- RAW EVENT DATA (Event $eventId) ---" -ForegroundColor Magenta
                foreach ($evt in $events | Select-Object -First 2) {
                  Write-Host "    TimeCreated: $($evt.TimeCreated)"

                  $xml = [xml]$evt.ToXml()
                  $eventData = $xml.Event.EventData.Data

                  switch ($eventId) {
                    4103 {  # Module Logging
                      $payload = ($eventData | Where-Object { $_.Name -eq 'Payload' }).'#text'
                      if ($payload) {
                        $payloadLines = $payload -split "`n" | Select-Object -First 5
                        Write-Host "    Payload (first 5 lines):"
                        foreach ($line in $payloadLines) {
                          Write-Host "      $($line.Trim())"
                        }
                      }
                    }
                    4104 {  # Script Block Logging
                      $scriptBlock = ($eventData | Where-Object { $_.Name -eq 'ScriptBlockText' }).'#text'
                      $scriptBlockId = ($eventData | Where-Object { $_.Name -eq 'ScriptBlockId' }).'#text'
                      Write-Host "    ScriptBlockId: $scriptBlockId"
                      if ($scriptBlock) {
                        $preview = $scriptBlock.Substring(0, [Math]::Min(300, $scriptBlock.Length))
                        Write-Host "    ScriptBlockText (preview): $preview..."
                      }
                    }
                  }
                  Write-Host "    ---"

                  $rawEventData += [PSCustomObject]@{
                    EventID = $eventId
                    TimeCreated = $evt.TimeCreated
                    Message = $evt.Message.Substring(0, [Math]::Min(500, $evt.Message.Length))
                  }
                }
                Write-Host ""
              }
              else {
                Write-Host "[--] Event $eventId : $description (not generated)" -ForegroundColor Yellow
                $status = "NOT_DETECTED"
                $totalMissing++
              }

              $results += [PSCustomObject]@{
                EventID = $eventId
                LogName = "PowerShell"
                Description = $description
                Status = $status
                Count = $count
              }
            }
            catch {
              Write-Host "[??] Event $eventId : $description (error reading)" -ForegroundColor Red
              $results += [PSCustomObject]@{
                EventID = $eventId
                LogName = "PowerShell"
                Description = $description
                Status = "ERROR"
                Count = 0
              }
            }
          }

          # Calculate coverage
          $total = $expectedSecurityEvents.Count + $expectedPowerShellEvents.Count
          $coverageRate = [math]::Round(($totalDetected / $total) * 100, 1)

          Write-Host "`n" + "=" * 60
          Write-Host "WINDOWS EVENT COVERAGE SUMMARY - ${{ matrix.config }}"
          Write-Host "=" * 60
          Write-Host "Events Tested: $total"
          Write-Host "Events Detected: $totalDetected" -ForegroundColor Green
          Write-Host "Events Missing: $totalMissing" -ForegroundColor Yellow
          Write-Host "Coverage Rate: $coverageRate%" -ForegroundColor Cyan

          # Export results
          $results | Export-Csv -Path "windows-event-coverage-${{ matrix.config }}.csv" -NoTypeInformation

          # Export raw event data
          $rawEventData | Export-Csv -Path "windows-event-raw-${{ matrix.config }}.csv" -NoTypeInformation

          # Create markdown report
          $mdContent = @"
          # Windows Event Coverage Report - ${{ matrix.config }}

          **Date:** $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
          **Configuration:** ${{ matrix.config }}
          **Coverage Rate:** $coverageRate%

          ## Summary
          | Metric | Count |
          |--------|-------|
          | Events Tested | $total |
          | Detected | $totalDetected |
          | Not Detected | $totalMissing |

          ## Detailed Results
          | Event ID | Description | Status | Count |
          |----------|-------------|--------|-------|
          "@

          foreach ($r in $results | Sort-Object EventID) {
            $statusEmoji = switch ($r.Status) {
              "DETECTED" { "✅" }
              "NOT_DETECTED" { "⚠️" }
              default { "❌" }
            }
            $mdContent += "`n| $($r.EventID) | $($r.Description) | $statusEmoji $($r.Status) | $($r.Count) |"
          }

          $mdContent | Out-File -FilePath "windows-event-report-${{ matrix.config }}.md" -Encoding UTF8

          # Fail if critical events are missing
          $criticalEvents = @(4720, 4732, 4697, 4698)  # Must detect these
          $criticalMissing = $results | Where-Object {
            $criticalEvents -contains $_.EventID -and $_.Status -ne "DETECTED"
          }

          if ($criticalMissing) {
            Write-Host "`n[WARNING] Critical events not detected:" -ForegroundColor Red
            $criticalMissing | ForEach-Object { Write-Host "  - $($_.EventID): $($_.Description)" }
            # Don't fail the build, just warn
          }

      - name: Cleanup Test Artifacts
        if: always()
        shell: powershell
        run: |
          Write-Host "Cleaning up test artifacts..."
          $ErrorActionPreference = 'SilentlyContinue'

          # Remove test user (ignore if doesn't exist)
          net user TestAuditUser /delete 2>&1 | Out-Null
          if ($LASTEXITCODE -eq 0) { Write-Host "  Removed user TestAuditUser" }

          # Remove test group (ignore if doesn't exist)
          net localgroup TestAuditGroup /delete 2>&1 | Out-Null
          if ($LASTEXITCODE -eq 0) { Write-Host "  Removed group TestAuditGroup" }

          Write-Host "Cleanup complete"
          exit 0

      - name: Upload Windows Event Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-event-results-${{ matrix.config }}
          path: |
            windows-event-coverage-${{ matrix.config }}.csv
            windows-event-report-${{ matrix.config }}.md
            windows-event-raw-${{ matrix.config }}.csv
            event-generation-results.csv
          if-no-files-found: ignore

  # ==========================================================================
  # MULTI-LANGUAGE AUDIT POLICY TESTS
  # Verifies that the audit policy script works on non-English Windows
  # Uses GUIDs instead of localized subcategory names
  # ==========================================================================
  multilang-audit-test:
    name: Audit Policy - ${{ matrix.locale }}
    needs: validate-xml
    runs-on: windows-latest
    if: github.event_name == 'workflow_dispatch'
    strategy:
      fail-fast: false
      matrix:
        locale: [it-IT, de-DE, fr-FR, es-ES]
        include:
          - locale: it-IT
            language: Italian
          - locale: de-DE
            language: German
          - locale: fr-FR
            language: French
          - locale: es-ES
            language: Spanish

    steps:
      - uses: actions/checkout@v4

      - name: Configure ${{ matrix.language }} Locale
        shell: powershell
        run: |
          Write-Host "Configuring system for ${{ matrix.language }} locale testing..."
          Write-Host "=" * 60

          # Set the Windows display language (affects auditpol output)
          # Note: This changes the UI locale which affects how auditpol displays subcategory names
          Set-WinUILanguageOverride -Language "${{ matrix.locale }}"
          Set-WinUserLanguageList -LanguageList "${{ matrix.locale }}" -Force
          Set-Culture -CultureInfo "${{ matrix.locale }}"

          Write-Host "Locale configured: ${{ matrix.locale }}"
          Write-Host "Current culture: $((Get-Culture).Name)"
          Write-Host ""

          # Show that auditpol would use localized names (this is what we're testing against)
          Write-Host "Sample auditpol output (to show localized names):"
          auditpol /get /subcategory:"{0CCE9215-69AE-11D9-BED3-505054503030}" 2>&1 | Select-Object -First 5

      - name: Test Audit Policy Script with GUIDs
        shell: powershell
        run: |
          Write-Host "Testing audit policy script with ${{ matrix.language }} locale..."
          Write-Host "=" * 60
          Write-Host ""
          Write-Host "This tests that GUIDs work regardless of Windows language."
          Write-Host "Before this fix, Italian Windows would fail with error 0x00000057"
          Write-Host ""

          # Run the audit policy script
          $ErrorActionPreference = 'Continue'
          & .\deploy\windows-audit-policy.ps1 -Verbose

          # Check results
          $exitCode = $LASTEXITCODE
          Write-Host ""
          Write-Host "Script exit code: $exitCode"

      - name: Verify Audit Policies Applied
        shell: powershell
        run: |
          Write-Host "Verifying audit policies were applied correctly..."
          Write-Host "=" * 60

          # Test a few key policies using GUIDs
          $testPolicies = @{
            "{0CCE9215-69AE-11D9-BED3-505054503030}" = "Logon"
            "{0CCE9235-69AE-11D9-BED3-505054503030}" = "User Account Management"
            "{0CCE9237-69AE-11D9-BED3-505054503030}" = "Security Group Management"
            "{0CCE922F-69AE-11D9-BED3-505054503030}" = "Audit Policy Change"
            "{0CCE9211-69AE-11D9-BED3-505054503030}" = "Security System Extension"
          }

          $passed = 0
          $failed = 0

          foreach ($guid in $testPolicies.Keys) {
            $policyName = $testPolicies[$guid]
            Write-Host "`nChecking: $policyName ($guid)"

            $result = auditpol /get /subcategory:$guid 2>&1
            $exitCode = $LASTEXITCODE

            if ($exitCode -eq 0) {
              Write-Host "  [OK] Policy accessible via GUID" -ForegroundColor Green
              $passed++

              # Show the setting
              $result | Select-Object -Skip 2 | ForEach-Object { Write-Host "  $_" }
            } else {
              Write-Host "  [FAIL] Could not access policy: $result" -ForegroundColor Red
              $failed++
            }
          }

          Write-Host "`n" + "=" * 60
          Write-Host "MULTI-LANGUAGE AUDIT POLICY TEST RESULTS"
          Write-Host "=" * 60
          Write-Host "Locale: ${{ matrix.locale }} (${{ matrix.language }})"
          Write-Host "Policies Passed: $passed" -ForegroundColor Green
          Write-Host "Policies Failed: $failed" -ForegroundColor $(if($failed -gt 0){'Red'}else{'Green'})

          if ($failed -gt 0) {
            Write-Host "`n[ERROR] Some policies failed to apply with ${{ matrix.language }} locale!" -ForegroundColor Red
            exit 1
          } else {
            Write-Host "`n[SUCCESS] All policies applied correctly with ${{ matrix.language }} locale!" -ForegroundColor Green
          }

      - name: Export Test Results
        if: always()
        shell: powershell
        run: |
          # Export current audit policy to CSV
          $outputFile = "audit-policy-${{ matrix.locale }}.csv"
          auditpol /get /category:* /r 2>&1 | Out-File -FilePath $outputFile -Encoding UTF8
          Write-Host "Audit policy exported to $outputFile"

      - name: Upload Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: audit-policy-${{ matrix.locale }}
          path: audit-policy-${{ matrix.locale }}.csv
          if-no-files-found: ignore

  summary:
    name: Test Summary
    needs: [test-sysmon-configs]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: results
          pattern: sysmon-events-*
          merge-multiple: true
        continue-on-error: true

      - name: Generate Summary
        run: |
          echo "# Sysmon Detection Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Configuration Test Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Config | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| ws | ${{ needs.test-sysmon-configs.result == 'success' && '✅ Passed' || '⚠️ Check logs' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| srv | ${{ needs.test-sysmon-configs.result == 'success' && '✅ Passed' || '⚠️ Check logs' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| dc | ${{ needs.test-sysmon-configs.result == 'success' && '✅ Passed' || '⚠️ Check logs' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| sql | ${{ needs.test-sysmon-configs.result == 'success' && '✅ Passed' || '⚠️ Check logs' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| exch | ${{ needs.test-sysmon-configs.result == 'success' && '✅ Passed' || '⚠️ Check logs' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| iis | ${{ needs.test-sysmon-configs.result == 'success' && '✅ Passed' || '⚠️ Check logs' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "Event logs from each configuration are available in the workflow artifacts." >> $GITHUB_STEP_SUMMARY
